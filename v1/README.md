
# アプリ概要

* 上部タブで3モードを切替：**縦振り** / **横振り** / **文字列変換**。
* 入力・再生・可視化・デコードを統合したモールス練習／検証アプリ。

# 用語

* **dit(・)** = dot, 1単位
* **dash(ー)** = dash, 3単位
* **単位(1u)**: WPMに依存（例: 20WPM ? 60ms）。
* **スクウィーズ**: 横振りで左右同時押し状態。

---

# 基本仕様

## 時間定義（WPM依存）

* 1u = 1200 / WPM [ms]

  * dot = 1u
  * dash = 3u
  * 要素間ギャップ = 1u
  * 文字間ギャップ = 3u
  * 単語間ギャップ = 7u
* WPM・周波数を変更すると、内部の各時間を即時再計算する。

## 出力（表示 & 音）

* 入力された要素を **. / -** で逐次表示。
* デコード結果を文字として表示更新。
* 音はWeb Audio APIでサイドトーンを生成し再生。

---

# 入力モード仕様

## 縦振り（ストレートキー）

* 単一入力の押下/離上エッジを取得。押下時間を単位長で正規化して **dit / dash** を判定。
* 要素確定のタイミングで表示・デコード更新・音再生。

## 横振り（エレキーパドル）

横振りは、tonefixed_clean 時点で以下の**安定ロジック**を使用。

### 1) エッジ検出 → 要求化（取りこぼし防止）

* **右(dash)ホールド中に左(dit)を押下**: `dotReqCountWhileDashHold++`
* **左(dit)ホールド中に右(dash)を押下**: `dashReqCountWhileDotHold++`
* 短いタップでも**DOWNエッジで即カウント**するため、取りこぼしが発生しない。

### 2) 要素完了直前の強制決定

* 送信中要素が終わる直前(数ms前)にパドル状態を観測し、

  * **'.' 終了時に右または両押し** → 次は **'-'** を強制
  * **'-' 終了時に左または両押し** → 次は **'.'** を強制
* `forceNextElement` としてスケジューラで**最優先採用**。
* 目的：`--` や `..` の混入を強力に抑止。

### 3) スケジューラの選択順序

1. `forceNextElement`（完了直前の強制）
2. **要求カウント消費**

   * 直前が `-` & 右ホールド & `dotReqCountWhileDashHold > 0` → 次は `.`（カウント--）
   * 直前が `.` & 左ホールド & `dashReqCountWhileDotHold > 0` → 次は `-`（カウント--）
3. 後方互換の要求フラグ（`reqDot` / `reqDash`）の消費
4. 通常判定（スクウィーズ時は**前回の反対** / 片側ホールド / ラッチ救済）

### 4) 期待挙動

* 右(dash)を押しっぱなし＋左(dit)高速連打 → **`-.-.-.-.` へ自然収束**し、`--`は出にくい。
* 左右逆も対称。

## 文字列変換

* 入力テキストを国際モールス表で **. / - / /** に変換。
* **AudioContext時間軸に先行スケジュール**して鳴らす（Jitter抑制）。

---

# オーディオ構成（tonefixed_clean 時点）

## サイドトーン・チェーン

* Oscillator（sine, 可変周波数） → Gain（エンベロープ） → BiquadFilter（bandpass, Q?10） → DynamicsCompressor（軽整形） → Destination
* **常時発振＋ゲイン0待機**方針（クリック抑制, 周波数変更の滑らかさ）。

## エンベロープ

* 立ち上がり/立下りは **短いフェード**でクリック抑止。
* 実装によっては **`setTargetAtTime`（指数）** と **`linearRampToValueAtTime`（線形）** が混在しがち。
* 立ち上がり時間・カーブは**モード間で統一されていない可能性**あり（後述の課題）。

## 先行スケジュール（文字列変換）

* 1度 `cancelScheduledValues(now)` で初期化 → **全要素を時間軸に予約**。
* 各要素の頭でゲインに短いランプを掛けてクリックレス化。

---

# 既知の問題（tonefixed_clean に対して解決が必要な点）

> ユーザー観測（Audacityによる実測）と体感に基づく。横振りの音は好ましいが、**縦振り**と**文字列変換**に課題。

## 1) モード間の**音量バランス不一致**

* **横振り**の音量が、**縦振り／文字列変換**と比べて「**半分程度**に聞こえる」ケースがある。
* 原因候補

  * `envLevel`（ゲイン上限）のモードごとの差
  * Compressor設定の違いによる**ピークの抑え込み**／平均レベルの差
  * 立ち上がり時間の違いに起因する**体感ラウドネス差**（同じピークでも短アタックは小さく聞こえやすい）
* 症状

  * 横振りの方が**立ち上がりは速い**が、**音量は小さく**感じる。
  * 縦振り／文字列変換は**音量は良い**（十分）が、立ち上がりが遅い。

## 2) モード間の**立ち上がり時間の不一致**

* 実測例（目安）

  * **横振り**：~**1ms**（好ましい）
  * **縦振り**：~**12ms**
  * **文字列変換**：~**15ms**
* 望ましい状態

  * **縦振り／文字列変換**も、**~3?5ms程度**の素早い立ち上がり（クリックは出さない範囲で最短化）。
  * **横振り**は現状の素早い立ち上がり（~1?2ms）を維持。

## 3) **立ち上がりカーブ**（線形 vs 指数）の不一致

* 観測

  * **縦振り**：**指数（コンデンサ充電型）**のような見え方 → 「モッサリ」感
  * **文字列変換**：**線形**だが立ち上がり時間が長い（~15ms）
  * **横振り**：立ち上がりが非常に速く自然
* 望ましい状態

  * 3モードとも**同じカーブ（推奨：線形）**で、**短いアタック**を実現。
  * これにより、モードを跨いだ時も音質印象が一定になる。

## 4) Compressorの影響差

* 速いアタックを**抑え込んでしまう**設定（高い比率・長めのアタック）が入ると、立ち上がりの見え方・体感音量が変化。
* **横振り**だけライトな設定／**縦・文字列**で強め（または有効/無効の差）があると、結果が揃わない。

---

# （参考）改善の方向性・受け入れ基準（この段階では仕様記述のみ）

※ここは「どう直すか」ではなく、「どういう状態に揃えたいか」を**受け入れ基準**として明記します。実装は次段。

### 音量（相対レベル）

* 3モードの**体感音量を±2dB以内**で一致させる（同一周波数・同一WPM・同一出力先で比較）。
* 横振りだけ小さく聞こえる現象を解消。
  （例: `envLevel` のモード別定数化＋Compressor閾値/比率の統一・軽量化）

### 立ち上がり時間（Attack）

* **横振り**：現状の**~1?2ms**を維持。
* **縦振り／文字列**：**~3?5ms**（Audacityで波形上、0→最大の95%近傍までの時間）に短縮。
* 3モードとも**“十分短く、クリックレス”**な範囲に収める。

### 立ち上がりカーブ（エンベロープ形状）

* 3モードで**同一カーブ**を使用（推奨：`linearRampToValueAtTime`）。
* `setTargetAtTime`（指数特性）の混在があれば排除して統一。

### 先行スケジュールとキャンセル方針（文字列）

* **最初に一度だけ**`cancelScheduledValues(now)`で初期化。
* 各要素の直前で**短い線形ランプ**を予約（**以後キャンセルしない**）。
* これによりテンポの揺れ・クリック再発を防ぐ。

---

# 仕様（抜粋）に残すべき定数/フック

* `setEnvelope(mode)`：

  * `mode ∈ { 'paddle', 'straight', 'text' }`
  * `envAttack`（秒）, `envRelease`（秒）, `envLevel`（0?1）を**モード別に定義**
  * ※ 受け入れ基準に合わせて、デフォルト例：

    * paddle: attack=0.0015, release=0.003, level=0.50（速攻＆やや大きめ）
    * straight/text: attack=0.0020?0.0030, release=0.003, level=0.35（見かけ3?5ms）
* `setCompForMode(mode)`（任意だが推奨）

  * paddle: 軽い整形（例: Thr -18, Ratio 2:1, Attack 1ms, Release 80ms）
  * straight/text: ほぼバイパス（例: Thr 0, Ratio 1:1）
* `scheduleToneAt(start, durationMs)`

  * **線形ランプ**で`envLevel`まで持ち上げ、終了時に0へ戻す。
  * 既存予約はキャンセルしない（**先行スケジュール維持**）。
* `sendElementUnified(...)` の先頭で `setEnvelope('paddle')` を適用（横振りの音質一貫性を保証）。

---

# まとめ

* **横振り**は入力ロジック・音の立ち上がりともに良好。
* **縦振り／文字列変換**は、**立ち上がり時間が長い（~12?15ms）**・**音量は良いが立ち上がりカーブが統一されていない**という差異が残っている。
* **tonefixed_clean** を基準に、上記の**受け入れ基準**（音量±2dB、Attack 3?5ms、線形カーブ統一）を満たすように、


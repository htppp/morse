<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>モールス体験</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Segoe UI', 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .settings-icon {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        .settings-icon:hover {
            transform: rotate(90deg) scale(1.1);
        }
        
        .settings-icon svg {
            width: 28px;
            height: 28px;
            fill: #667eea;
        }
        
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .settings-modal.active {
            display: flex;
        }
        
        .settings-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .settings-header h2 {
            font-size: 24px;
            color: #333;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 32px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 25px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 20px 20px 0 0;
        }
        
        .header h1 {
            font-size: 28px;
            font-weight: 600;
        }
        
        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab {
            flex: 1;
            padding: 16px 20px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .tab:hover { background: #e9ecef; color: #333; }
        .tab.active {
            background: white;
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            margin-bottom: 25px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .section h2 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 20px;
            font-weight: 600;
            padding-bottom: 12px;
            border-bottom: 2px solid #667eea;
        }
        
        input, textarea, button, select {
            font-size: 15px;
            padding: 12px 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

            #textLog {
                border: 1.5px solid #667eea;
                background: #f8f9fa;
                font-size: 16px;
                margin-bottom: 10px;
                padding: 10px 16px;
                border-radius: 8px;
                list-style: none;
                overflow-y: visible;
                height: auto;
                max-height: none;
                min-height: 0;
                transition: height 0.2s;
            }
            #textLog li {
                padding: 7px 12px;
                margin-bottom: 4px;
                background: #fff;
                border-radius: 6px;
                border: 1px solid #e0e0e0;
                box-shadow: 0 1px 4px rgba(102,126,234,0.07);
                transition: background 0.2s;
            }
            #textLog li:hover {
                background: #e3e7fa;
            }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        input[type="text"], textarea {
            width: 100%;
            margin-bottom: 15px;
        }
        
        input[type="number"] {
            width: 100%;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            padding: 12px 24px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:active { transform: translateY(0); }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .morse-display {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            min-height: 60px;
            word-wrap: break-word;
            letter-spacing: 2px;
            border: 2px solid #e0e0e0;
            margin-bottom: 15px;
        }
        
        .controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .morse-key {
            font-size: 32px;
            font-weight: bold;
            padding: 50px 70px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 50%;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            margin: 30px auto;
            display: block;
            min-width: 200px;
            min-height: 200px;
            box-shadow: 0 10px 30px rgba(245, 87, 108, 0.4);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .morse-key:hover {
            transform: translateY(-5px) scale(1.02);
        }
        
        .morse-key:active {
            transform: translateY(0) scale(0.98);
        }
        
        .paddle-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px auto;
        }
        
        .paddle-key {
            font-size: 22px;
            font-weight: bold;
            padding: 40px 50px;
            color: white;
            border: none;
            border-radius: 15px;
            user-select: none;
            min-width: 140px;
            min-height: 170px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .paddle-left {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .paddle-left:hover {
            transform: translateY(-5px);
        }
        
        .paddle-left:active, .paddle-left.active {
            transform: scale(0.95);
        }
        
        .paddle-right {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        
        .paddle-right:hover {
            transform: translateY(-5px);
        }
        
        .paddle-right:active, .paddle-right.active {
            transform: scale(0.95);
        }
        
        .keyboard-hint {
            text-align: center;
            font-size: 14px;
            color: #666;
            margin-top: 15px;
            font-style: italic;
            background: #fff3cd;
            padding: 10px;
            border-radius: 6px;
        }
        
        .decoded-output {
            background: white;
            padding: 20px;
            border-radius: 8px;
            min-height: 50px;
            font-weight: bold;
            font-size: 18px;
            border: 2px solid #e0e0e0;
            color: #333;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-item label {
            font-weight: 600;
            color: #555;
            font-size: 15px;
        }
        
        .setting-item input[type="range"] {
            width: 100%;
        }
        
        .setting-value {
            font-size: 14px;
            color: #667eea;
            font-weight: 700;
            text-align: right;
        }
        
        .setting-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            align-items: center;
        }
        
        #timingInfo {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.8;
            border: 2px solid #90caf9;
            margin-top: 15px;
        }
        
        .squeeze-indicator {
            text-align: center;
            margin-top: 15px;
            font-size: 16px;
            font-weight: bold;
            color: #ff6b00;
            opacity: 0;
            transition: opacity 0.2s;
            background: #fff3cd;
            padding: 10px;
            border-radius: 6px;
        }
        
        .squeeze-indicator.active { opacity: 1; }
    </style>
</head>
<body>
    <div class="settings-icon" id="settingsIcon">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
    </div>

    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2>設定</h2>
                <button class="close-btn" id="closeSettings">&times;</button>
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-row">
                        <label>音量</label>
                        <span class="setting-value" id="volumeValue">30%</span>
                    </div>
                    <input type="range" id="volumeRange" min="0" max="100" value="30">
                </div>
                <div class="setting-item">
                    <label>周波数 (Hz)</label>
                    <input type="number" id="globalFrequency" list="frequencyList" min="100" max="2000" value="600" step="50">
                    <datalist id="frequencyList">
                        <option value="300">
                        <option value="350">
                        <option value="400">
                        <option value="450">
                        <option value="500">
                        <option value="550">
                        <option value="600">
                        <option value="650">
                        <option value="700">
                        <option value="750">
                        <option value="800">
                        <option value="850">
                        <option value="900">
                        <option value="950">
                        <option value="1000">
                    </datalist>
                </div>
                <div class="setting-item">
                    <label>WPM (速度: 1-999)</label>
                    <input type="number" id="globalWPM" min="1" max="999" value="20">
                </div>
                <div class="setting-item">
                    <label>縦振りキー</label>
                    <input type="text" id="straightKey" value="Space">
                </div>
                <div class="setting-item">
                    <label>横振り左キー</label>
                    <input type="text" id="paddleLeftKey" value="j">
                </div>
                <div class="setting-item">
                    <label>横振り右キー</label>
                    <input type="text" id="paddleRightKey" value="k">
                </div>
                <div class="setting-item">
                    <label>Iambic モード</label>
                    <select id="iambicMode">
                        <option value="A">Iambic A</option>
                        <option value="B" selected>Iambic B</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>横振りパドル配置</label>
                    <select id="paddleLayout">
                        <option value="normal" selected>通常 (左:短点 / 右:長点)</option>
                        <option value="reversed">反転 (左:長点 / 右:短点)</option>
                    </select>
                </div>
            </div>
            <div style="text-align: center; margin-top: 25px;">
                <button id="settingsOK" style="min-width: 120px;">OK</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>モールス体験</h1>
        </div>
        
        <div class="tabs">
            <button class="tab active" data-tab="straight">縦振り</button>
            <button class="tab" data-tab="paddle">横振り</button>
            <button class="tab" data-tab="text">文字列変換</button>
        </div>

        <div class="tab-content active" id="straight-content">
            <div class="section">
                <h2>縦振り電鍵</h2>
                <button class="morse-key" id="morseKey">KEY</button>
                <div class="keyboard-hint">
                    キーボード: <span id="straightKeyHint">Space</span>
                </div>
                <div class="morse-display" id="straightMorseDisplay">入力されたモールス信号</div>
                <div class="decoded-output" id="straightDecoded">解読された文字</div>
                <div style="text-align: center; margin-top: 20px;">
                    <button id="straightClear">クリア</button>
                </div>
            </div>
        </div>

        <div class="tab-content" id="paddle-content">
            <div class="section">
                <h2>横振り電鍵</h2>
                <div class="paddle-container">
                    <button class="paddle-key paddle-left" id="paddleLeft">
                        短点<br>・
                    </button>
                    <button class="paddle-key paddle-right" id="paddleRight">
                        長点<br>ー
                    </button>
                </div>
                <div class="keyboard-hint">
                    キーボード: <span id="paddleKeysHint">J / K</span>
                </div>
                <div class="squeeze-indicator" id="squeezeIndicator">
                    ⚡squeeze⚡
                </div>
                <div class="morse-display" id="paddleMorseDisplay">入力されたモールス信号</div>
                <div class="decoded-output" id="paddleDecoded">解読された文字</div>
                <div style="text-align: center; margin-top: 20px;">
                    <button id="paddleClear">クリア</button>
                </div>
            </div>
        </div>

        <div class="tab-content" id="text-content">
            <div class="section">
                <h2>文字列 → モールス信号</h2>
                <input type="text" id="textInput" placeholder="変換したいテキストを入力">
                <div class="morse-display" id="morseOutput">モールス信号が表示されます</div>
                <div class="controls">
                    <button id="playButton">再生</button>
                    <button id="stopButton" disabled>停止</button>
                </div>
            </div>
                <div class="section" id="textLogSection">
                    <h2>受理ログ</h2>
                    <ul id="textLog"></ul>
                    <button id="clearTextLog">ログクリア</button>
                </div>
        </div>
    </div>

    <script>
        "use strict";
        
        const MORSE_CODE_MAP = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..',
            '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
            '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.',
            ' ': '/', // 特殊。プログラムの都合上でしか使用しない。
            '.': '.-.-.-',
            ',': '--..--',
            ':': '---...',
            '?': '..--..',
            '_': '..--.-',
            '+': '.-.-.',
            '-': '-....-',
            '×': '-..-',
            '^': '......',
            '/': '-..-.',
            '@': '.--.-.',
            '(': '-.--.',
            ')': '-.--.-',
            '"': '.-..-.',
            "'": '.----.',
            'HH': '........', // 送信開始
            '=': '-...-', // = or 送信終了
            'VA': '...-.-', // 送信要求
            'AS': '.-...', // 待機要求
            'VE': '...-.', // 了解
        };
        
        const MORSE_TO_CHAR_MAP = Object.fromEntries(
            Object.entries(MORSE_CODE_MAP).map(([char, morse]) => [morse, char])
        );
        
        // タブ切り替え機能。
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const targetTab = this.dataset.tab;
                
                // タブのアクティブ状態を更新。
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // コンテンツの表示を切り替え。
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(targetTab + '-content').classList.add('active');
            });
        });
        
        // 設定モーダル。
        let modalMouseDownInside = false;
        
        document.getElementById('settingsIcon').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.add('active');
        });
        
        document.getElementById('closeSettings').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.remove('active');
        });
        
        document.getElementById('settingsOK').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.remove('active');
        });
        
        document.getElementById('settingsModal').addEventListener('mousedown', (e) => {
            // 設定コンテンツ内でマウスダウンしたかをチェック。
            modalMouseDownInside = e.target.closest('.settings-content') !== null;
        });
        
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            // モーダル背景をクリックした場合のみ閉じる（コンテンツ内で開始していない場合）。
            if (e.target.id === 'settingsModal' && !modalMouseDownInside) {
                document.getElementById('settingsModal').classList.remove('active');
            }
            modalMouseDownInside = false;
        });
        
        // 設定の読み込みと保存。
        let settings = {
            volume: 0.3,
            frequency: 600,
            wpm: 20,
            straightKey: 'Space',
            paddleLeft: 'j',
            paddleRight: 'k',
            iambicMode: 'B',
            paddleLayout: 'normal'
        };

            // 文字列変換タブ: Enterキーで受理・再生・ログ追加
            const textInput = document.getElementById('textInput');
            const playButton = document.getElementById('playButton');
            const textLog = document.getElementById('textLog');
            const clearTextLogBtn = document.getElementById('clearTextLog');
            let textLogArr = [];

            function addTextLog(str) {
                textLogArr.push(str);
                renderTextLog();
                localStorage.setItem('morseTextLog', JSON.stringify(textLogArr));
            }

            function renderTextLog() {
                 textLog.innerHTML = textLogArr.slice().reverse().map(x => `<li>${x}</li>`).join('');
            }

            function clearTextLog() {
                textLogArr = [];
                renderTextLog();
                localStorage.removeItem('morseTextLog');
            }

            // ログ初期化
            (() => {
                const saved = localStorage.getItem('morseTextLog');
                if (saved) {
                    textLogArr = JSON.parse(saved);
                    renderTextLog();
                }
            })();

            // 再生関数（既存の再生処理を呼び出す）
            function playTextInput(str) {
                // 既存の再生処理を直接呼び出す（playButtonのclickは呼ばない）
                textInput.value = str;
                // 既存の再生処理をここに記述（例: morse再生関数を呼ぶ）
                // 例: playMorse(str); など
                // playButton.click()は呼ばない
            }

            function acceptTextInput() {
                const val = textInput.value.trim();
                if (val) {
                    addTextLog(val);
                    playTextInput(val);
                    textInput.value = '';
                }
            }

            textInput.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    acceptTextInput();
                }
            });

            playButton.addEventListener('click', acceptTextInput);

            clearTextLogBtn.addEventListener('click', clearTextLog);
        
        let playHistory = [];
        
        function loadSettings() {
            const saved = localStorage.getItem('morseSettings');
            if (saved) {
                settings = { ...settings, ...JSON.parse(saved) };
            }
            const savedHistory = localStorage.getItem('morsePlayHistory');
            if (savedHistory) {
                playHistory = JSON.parse(savedHistory);
                updateHistoryDisplay();
            }
            document.getElementById('volumeRange').value = settings.volume * 100;
            document.getElementById('volumeValue').textContent = Math.round(settings.volume * 100) + '%';
            document.getElementById('globalFrequency').value = settings.frequency;
            document.getElementById('globalWPM').value = settings.wpm;
            document.getElementById('straightKey').value = settings.straightKey;
            document.getElementById('paddleLeftKey').value = settings.paddleLeft;
            document.getElementById('paddleRightKey').value = settings.paddleRight;
            document.getElementById('iambicMode').value = settings.iambicMode;
            const paddleLayoutSelect = document.getElementById('paddleLayout');
            if (paddleLayoutSelect) {
                paddleLayoutSelect.value = settings.paddleLayout;
            }
            updateKeyHints();
        }
        
        function saveSettings() {
            localStorage.setItem('morseSettings', JSON.stringify(settings));
        }
        
        function updateKeyHints() {
            document.getElementById('straightKeyHint').textContent = settings.straightKey;
            document.getElementById('paddleKeysHint').textContent = 
                settings.paddleLeft.toUpperCase() + ' / ' + settings.paddleRight.toUpperCase();
        }
        
        document.getElementById('volumeRange').addEventListener('input', (e) => {
            settings.volume = parseInt(e.target.value) / 100;
            document.getElementById('volumeValue').textContent = e.target.value + '%';
            saveSettings();
        });
        
        document.getElementById('globalFrequency').addEventListener('change', (e) => {
            let val = parseInt(e.target.value);
            if (isNaN(val) || val < 100) val = 100;
            if (val > 2000) val = 2000;
            e.target.value = val;
            settings.frequency = val;
            saveSettings();
        });
        
        document.getElementById('globalWPM').addEventListener('change', (e) => {
            let val = parseInt(e.target.value);
            if (isNaN(val) || val < 1) val = 1;
            if (val > 999) val = 999;
            e.target.value = val;
            settings.wpm = val;
            saveSettings();
        });
        
        document.getElementById('straightKey').addEventListener('change', (e) => {
            settings.straightKey = e.target.value.trim() || 'Space';
            updateKeyHints();
            saveSettings();
        });
        
        document.getElementById('paddleLeftKey').addEventListener('change', (e) => {
            settings.paddleLeft = e.target.value.trim() || 'j';
            updateKeyHints();
            saveSettings();
        });
        
        document.getElementById('paddleRightKey').addEventListener('change', (e) => {
            settings.paddleRight = e.target.value.trim() || 'k';
            updateKeyHints();
            saveSettings();
        });
        
        document.getElementById('iambicMode').addEventListener('change', (e) => {
            settings.iambicMode = e.target.value;
            saveSettings();
        });
        
        const paddleLayoutSelect = document.getElementById('paddleLayout');
        if (paddleLayoutSelect) {
            paddleLayoutSelect.addEventListener('change', (e) => {
                settings.paddleLayout = e.target.value;
                saveSettings();
                updatePaddleLayout();
            });
        }
        
        function updatePaddleLayout() {
            let container = document.getElementById('paddleContainerMain');
            // IDで見つからない場合はクラスで検索。
            if (!container) {
                const containers = document.getElementsByClassName('paddle-container');
                if (containers.length > 0) {
                    container = containers[0];
                }
            }
            
            const leftBtn = document.getElementById('paddleLeft');
            const rightBtn = document.getElementById('paddleRight');
            
            if (!container || !leftBtn || !rightBtn) {
                // 100ms後に再試行。
                setTimeout(() => {
                    let c = document.getElementById('paddleContainerMain');
                    if (!c) {
                        const cs = document.getElementsByClassName('paddle-container');
                        if (cs.length > 0) c = cs[0];
                    }
                    const l = document.getElementById('paddleLeft');
                    const r = document.getElementById('paddleRight');
                    if (c && l && r) {
                        if (settings.paddleLayout === 'reversed') {
                            // 左ボタンを長点に。
                            l.innerHTML = '長点<br>ー';
                            l.style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
                            // 右ボタンを短点に。
                            r.innerHTML = '短点<br>・';
                            r.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
                        } else {
                            // 左ボタンを短点に。
                            l.innerHTML = '短点<br>・';
                            l.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
                            // 右ボタンを長点に。
                            r.innerHTML = '長点<br>ー';
                            r.style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
                        }
                    }
                }, 100);
                return;
            }
            
            if (settings.paddleLayout === 'reversed') {
                // 左ボタンを長点に。
                leftBtn.innerHTML = '長点<br>ー';
                leftBtn.style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
                // 右ボタンを短点に。
                rightBtn.innerHTML = '短点<br>・';
                rightBtn.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
            } else {
                // 左ボタンを短点に。
                leftBtn.innerHTML = '短点<br>・';
                leftBtn.style.background = 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)';
                // 右ボタンを長点に。
                rightBtn.innerHTML = '長点<br>ー';
                rightBtn.style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
            }
        }
        
        function updateHistoryDisplay() {
            const historyDiv = document.getElementById('playHistory');
            if (!historyDiv) return;
            if (playHistory.length === 0) {
                historyDiv.textContent = '再生履歴はありません';
            } else {
                historyDiv.innerHTML = playHistory.map((item, i) => 
                    `<div>${i + 1}. ${item}</div>`
                ).join('');
            }
        }
        
        const clearHistoryBtn = document.getElementById('clearHistory');
        if (clearHistoryBtn) {
            clearHistoryBtn.addEventListener('click', () => {
                playHistory = [];
                localStorage.setItem('morsePlayHistory', JSON.stringify(playHistory));
                updateHistoryDisplay();
            });
        }
        
        // 音声システム。
        let audioContext = null;
        let sidOsc = null;
        let sidGain = null;
        let sidFilter = null;
        let isPlaying = false;
        
        function ensureAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
        
        function ensureSidetone() {
            ensureAudioContext();
            if (!sidOsc) {
                sidOsc = audioContext.createOscillator();
                sidGain = audioContext.createGain();
                sidFilter = audioContext.createBiquadFilter();
                const sidComp = audioContext.createDynamicsCompressor();
                
                sidOsc.type = 'sine';
                sidOsc.frequency.value = settings.frequency;
                sidGain.gain.value = 0;
                
                sidFilter.type = 'bandpass';
                sidFilter.frequency.value = settings.frequency;
                sidFilter.Q.value = 10;
                
                sidComp.threshold.value = -18;
                sidComp.ratio.value = 2.0;
                sidComp.attack.value = 0.001;
                sidComp.release.value = 0.08;
                
                sidOsc.connect(sidGain);
                sidGain.connect(sidFilter);
                sidFilter.connect(sidComp);
                sidComp.connect(audioContext.destination);
                sidOsc.start();
            }
        }
        
        function scheduleTone(startTime, durationMs) {
            ensureAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = settings.frequency;
                oscillator.type = 'sine';
                
                const now = audioContext.currentTime;
                const t0 = Math.max(now, startTime);
                gainNode.gain.setValueAtTime(0, t0);
                gainNode.gain.linearRampToValueAtTime(settings.volume, t0 + 0.001);
                gainNode.gain.setValueAtTime(settings.volume, t0 + (durationMs - 1) / 1000);
                gainNode.gain.linearRampToValueAtTime(0, t0 + durationMs / 1000);
                
                oscillator.start(t0);
                oscillator.stop(t0 + durationMs / 1000);
            } catch (error) {
                console.error('文字列変換音声エラー:', error);
            }
        }
        
        // テキスト変換機能。
        document.getElementById('textInput').addEventListener('input', (e) => {
            const text = e.target.value.toUpperCase();
            const morse = text.split('').map(char => MORSE_CODE_MAP[char] || char).join(' ');
            document.getElementById('morseOutput').textContent = morse || 'モールス信号が表示されます';
        });
        
        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const text = document.getElementById('textInput').value.trim();
                if (text) {
                    playHistory.push(text);
                    localStorage.setItem('morsePlayHistory', JSON.stringify(playHistory));
                    updateHistoryDisplay();
                    document.getElementById('playButton').click();
                }
            }
        });
        
        // 再生機能。
        document.getElementById('playButton').addEventListener('click', async () => {
            if (isPlaying) return;
            
            const morse = document.getElementById('morseOutput').textContent;
            if (!morse || morse === 'モールス信号が表示されます') return;
            
            ensureAudioContext();
            ensureSidetone();
            
            isPlaying = true;
            document.getElementById('playButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            
            // 周波数を更新。
            sidOsc.frequency.setValueAtTime(settings.frequency, audioContext.currentTime);
            sidFilter.frequency.setValueAtTime(settings.frequency, audioContext.currentTime);
            
            const unit = 1200 / settings.wpm;
            const dot = unit;
            const dash = 3 * unit;
            const egap = unit;
            const lgap = 3 * unit;
            const wgap = 7 * unit;
            
            let t = audioContext.currentTime + 0.02;
            
            for (let i = 0; i < morse.length && isPlaying; i++) {
                const ch = morse[i];
                if (ch === '.') {
                    scheduleTone(t, dot);
                    t += (dot + egap) / 1000;
                } else if (ch === '-') {
                    scheduleTone(t, dash);
                    t += (dash + egap) / 1000;
                } else if (ch === ' ') {
                    t += (lgap - egap) / 1000;
                } else if (ch === '/') {
                    t += (wgap - egap) / 1000;
                }
            }
            
            const totalMs = (t - audioContext.currentTime) * 1000;
            await new Promise(res => setTimeout(res, totalMs));
            
            if (isPlaying) {
                isPlaying = false;
                document.getElementById('playButton').disabled = false;
                document.getElementById('stopButton').disabled = true;
            }
        });
        
        document.getElementById('stopButton').addEventListener('click', () => {
            isPlaying = false;
            if (sidGain && audioContext) {
                const now = audioContext.currentTime;
                sidGain.gain.cancelScheduledValues(now);
                sidGain.gain.setValueAtTime(0, now);
            }
            document.getElementById('playButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
        });
        
        // 初期化。
        loadSettings();
        
        // AudioContextを事前初期化して遅延を最小化。
        document.addEventListener('click', () => {
            ensureAudioContext();
        }, { once: true });
        
        document.addEventListener('keydown', () => {
            ensureAudioContext();
        }, { once: true });
        
        // DOMContentLoaded後にパドルレイアウトを更新。
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                updatePaddleLayout();
            });
        } else {
            updatePaddleLayout();
        }
        
        // 縦振り電鍵機能。
        let straightKeyDown = false;
        let straightKeyDownTime = 0;
        let straightBuffer = '';
        let straightSequence = '';
        let straightLastInputTime = 0;
        let straightCharTimer = null;
        let straightWordTimer = null;
        
        function getTimings() {
            const unit = 1200 / settings.wpm;
            return {
                dot: unit,
                dash: unit * 3,
                charGap: unit * 4,
                wordGap: unit * 7
            };
        }
        
        function clearStraightTimers() {
            if (straightCharTimer) {
                clearTimeout(straightCharTimer);
                straightCharTimer = null;
            }
            if (straightWordTimer) {
                clearTimeout(straightWordTimer);
                straightWordTimer = null;
            }
        }
        
        function setStraightTimers() {
            clearStraightTimers();
            const timings = getTimings();
            
            straightCharTimer = setTimeout(() => {
                if (straightSequence) {
                    straightBuffer += straightSequence + ' ';
                    straightSequence = '';
                    updateStraightDisplay();
                }
            }, timings.charGap);
            
            straightWordTimer = setTimeout(() => {
                if (straightSequence) {
                    straightBuffer += straightSequence + ' ';
                    straightSequence = '';
                }
                if (!straightBuffer.endsWith('/ ')) {
                    straightBuffer += '/ ';
                }
                updateStraightDisplay();
            }, timings.wordGap);
        }
        
        function startStraightTone() {
            ensureAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            try {
                // 縦振りも毎回新しいOscillatorを作成。
                if (window.currentStraightOsc) {
                    try {
                        window.currentStraightOsc.stop();
                    } catch (e) {}
                }
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = settings.frequency;
                oscillator.type = 'sine';
                
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(settings.volume, now + 0.001);
                
                oscillator.start(now);
                
                window.currentStraightOsc = oscillator;
                window.currentStraightGain = gainNode;
            } catch (error) {
                console.error('縦振り開始エラー:', error);
            }
        }
        
        function stopStraightTone() {
            try {
                if (window.currentStraightOsc && window.currentStraightGain) {
                    const now = audioContext.currentTime;
                    window.currentStraightGain.gain.cancelScheduledValues(now);
                    window.currentStraightGain.gain.setValueAtTime(window.currentStraightGain.gain.value, now);
                    window.currentStraightGain.gain.linearRampToValueAtTime(0, now + 0.001);
                    window.currentStraightOsc.stop(now + 0.002);
                    window.currentStraightOsc = null;
                    window.currentStraightGain = null;
                }
            } catch (error) {
                console.error('縦振り停止エラー:', error);
            }
        }
        
        document.getElementById('morseKey').addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (straightKeyDown) return;
            ensureAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            straightKeyDown = true;
            straightKeyDownTime = Date.now();
            clearStraightTimers();
            startStraightTone();
        });
        
        document.getElementById('morseKey').addEventListener('mouseup', () => {
            if (!straightKeyDown) return;
            straightKeyDown = false;
            const duration = Date.now() - straightKeyDownTime;
            stopStraightTone();
            
            const timings = getTimings();
            const signal = duration < timings.dash ? '.' : '-';
            straightSequence += signal;
            straightLastInputTime = Date.now();
            updateStraightDisplay();
            setStraightTimers();
        });
        
        document.getElementById('morseKey').addEventListener('mouseleave', () => {
            if (straightKeyDown) {
                straightKeyDown = false;
                stopStraightTone();
                const duration = Date.now() - straightKeyDownTime;
                const timings = getTimings();
                const signal = duration < timings.dash ? '.' : '-';
                straightSequence += signal;
                straightLastInputTime = Date.now();
                updateStraightDisplay();
                setStraightTimers();
            }
        });

        // タッチイベント対応（スマートフォン用）
        document.getElementById('morseKey').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (straightKeyDown) return;
            ensureAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            straightKeyDown = true;
            straightKeyDownTime = Date.now();
            clearStraightTimers();
            startStraightTone();
        }, { passive: false });

        document.getElementById('morseKey').addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!straightKeyDown) return;
            straightKeyDown = false;
            const duration = Date.now() - straightKeyDownTime;
            stopStraightTone();

            const timings = getTimings();
            const signal = duration < timings.dash ? '.' : '-';
            straightSequence += signal;
            straightLastInputTime = Date.now();
            updateStraightDisplay();
            setStraightTimers();
        }, { passive: false });

        document.getElementById('morseKey').addEventListener('touchcancel', (e) => {
            e.preventDefault();
            if (straightKeyDown) {
                straightKeyDown = false;
                stopStraightTone();
                const duration = Date.now() - straightKeyDownTime;
                const timings = getTimings();
                const signal = duration < timings.dash ? '.' : '-';
                straightSequence += signal;
                straightLastInputTime = Date.now();
                updateStraightDisplay();
                setStraightTimers();
            }
        }, { passive: false });
        
        function updateStraightDisplay() {
            let display = '';
            if (straightBuffer) {
                display = straightBuffer.trim();
            }
            if (straightSequence) {
                if (display) display += ' ';
                display += `[${straightSequence}]`;
            }
            document.getElementById('straightMorseDisplay').textContent = display || '入力されたモールス信号';
            updateStraightDecoded();
        }
        
        function updateStraightDecoded() {
            const sequences = straightBuffer.trim().split(/\s+/);
            let decoded = '';
            for (const seq of sequences) {
                if (seq === '/') {
                    decoded += ' ';
                } else if (seq && seq !== '') {
                    decoded += MORSE_TO_CHAR_MAP[seq] || '?';
                }
            }
            document.getElementById('straightDecoded').textContent = decoded || '解読された文字';
        }
        
        document.getElementById('straightClear').addEventListener('click', () => {
            straightBuffer = '';
            straightSequence = '';
            clearStraightTimers();
            updateStraightDisplay();
        });
        
        // 横振り電鍵機能。
        let paddleLeftDown = false;
        let paddleRightDown = false;
        let paddleBuffer = '';
        let paddleSequence = '';
        let paddleSending = false;
        let paddleLastSent = null;
        let paddleLastInputTime = 0;
        let paddleCharTimer = null;
        let paddleWordTimer = null;
        let dotReqCount = 0;
        let dashReqCount = 0;
        let forceNextElement = null;
        
        function clearPaddleTimers() {
            if (paddleCharTimer) {
                clearTimeout(paddleCharTimer);
                paddleCharTimer = null;
            }
            if (paddleWordTimer) {
                clearTimeout(paddleWordTimer);
                paddleWordTimer = null;
            }
        }
        
        function setPaddleTimers() {
            clearPaddleTimers();
            const timings = getTimings();
            
            paddleCharTimer = setTimeout(() => {
                if (paddleSequence) {
                    paddleBuffer += paddleSequence + ' ';
                    paddleSequence = '';
                    updatePaddleDisplay();
                }
            }, timings.charGap);
            
            paddleWordTimer = setTimeout(() => {
                if (paddleSequence) {
                    paddleBuffer += paddleSequence + ' ';
                    paddleSequence = '';
                }
                if (!paddleBuffer.endsWith('/ ')) {
                    paddleBuffer += '/ ';
                }
                updatePaddleDisplay();
            }, timings.wordGap);
        }
        
        function sendPaddleElement(element) {
            if (paddleSending) return;
            paddleSending = true;
            clearPaddleTimers();
            
            const unit = 1200 / settings.wpm;
            const duration = element === '.' ? unit : unit * 3;
            
            ensureAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            try {
                // 毎回新しいOscillatorとGainNodeを作成（元の実装方式）。
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = settings.frequency;
                oscillator.type = 'sine';
                
                // 超高速エンベロープ（1msで立ち上げ）。
                const now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(settings.volume, now + 0.001);
                gainNode.gain.setValueAtTime(settings.volume, now + (duration - 1) / 1000);
                gainNode.gain.linearRampToValueAtTime(0, now + duration / 1000);
                
                oscillator.start(now);
                oscillator.stop(now + duration / 1000);
                
                paddleSequence += element;
                paddleLastInputTime = Date.now();
                updatePaddleDisplay();
                paddleLastSent = element;
                
                // 要素完了直前に次要素を強制決定する。
                setTimeout(() => {
                    const both = paddleLeftDown && paddleRightDown;
                    if (element === '.' && (paddleRightDown || both)) {
                        forceNextElement = '-';
                    } else if (element === '-' && (paddleLeftDown || both)) {
                        forceNextElement = '.';
                    }
                }, duration - 5);
                
                setTimeout(() => {
                    paddleSending = false;
                    if (paddleLeftDown || paddleRightDown) {
                        scheduleNextPaddle();
                    } else {
                        setPaddleTimers();
                    }
                }, duration + unit);
            } catch (error) {
                console.error('横振り音声エラー:', error);
                paddleSending = false;
            }
        }
        
        function scheduleNextPaddle() {
            if (paddleSending) return;
            
            let next = null;
            
            // 1. 強制次要素を最優先。
            if (forceNextElement) {
                next = forceNextElement;
                forceNextElement = null;
            }
            
            // 2. 要求カウントを消費。
            if (!next) {
                if (paddleLastSent === '-' && paddleRightDown && dotReqCount > 0) {
                    next = '.';
                    dotReqCount--;
                } else if (paddleLastSent === '.' && paddleLeftDown && dashReqCount > 0) {
                    next = '-';
                    dashReqCount--;
                }
            }
            
            // 3. 通常判定。
            if (!next) {
                if (paddleLeftDown && paddleRightDown) {
                    next = paddleLastSent === '.' ? '-' : '.';
                } else if (paddleLeftDown) {
                    next = '.';
                } else if (paddleRightDown) {
                    next = '-';
                }
            }
            
            if (next) {
                sendPaddleElement(next);
            }
        }
        
        document.getElementById('paddleLeft').addEventListener('mousedown', () => {
            if (paddleLeftDown) return;
            paddleLeftDown = true;
            
            // 右ホールド中に左押下 → ディット要求をカウント。
            if (paddleRightDown) {
                dotReqCount++;
            }
            
            document.getElementById('paddleLeft').classList.add('active');
            updateSqueezeIndicator();
            if (!paddleSending) {
                sendPaddleElement('.');
            }
        });
        
        document.getElementById('paddleLeft').addEventListener('mouseup', () => {
            paddleLeftDown = false;
            dashReqCount = 0;
            document.getElementById('paddleLeft').classList.remove('active');
            updateSqueezeIndicator();
        });
        
        document.getElementById('paddleRight').addEventListener('mousedown', () => {
            if (paddleRightDown) return;
            paddleRightDown = true;
            
            // 左ホールド中に右押下 → ダッシュ要求をカウント。
            if (paddleLeftDown) {
                dashReqCount++;
            }
            
            document.getElementById('paddleRight').classList.add('active');
            updateSqueezeIndicator();
            if (!paddleSending) {
                sendPaddleElement('-');
            }
        });
        
        document.getElementById('paddleRight').addEventListener('mouseup', () => {
            paddleRightDown = false;
            dotReqCount = 0;
            document.getElementById('paddleRight').classList.remove('active');
            updateSqueezeIndicator();
        });
        
        function updateSqueezeIndicator() {
            const squeezing = paddleLeftDown && paddleRightDown;
            if (squeezing) {
                document.getElementById('squeezeIndicator').classList.add('active');
            } else {
                document.getElementById('squeezeIndicator').classList.remove('active');
            }
        }
        
        function updatePaddleDisplay() {
            let display = '';
            if (paddleBuffer) {
                display = paddleBuffer.trim();
            }
            if (paddleSequence) {
                if (display) display += ' ';
                display += `[${paddleSequence}]`;
            }
            document.getElementById('paddleMorseDisplay').textContent = display || '入力されたモールス信号';
            updatePaddleDecoded();
        }
        
        function updatePaddleDecoded() {
            const sequences = paddleBuffer.trim().split(/\s+/);
            let decoded = '';
            for (const seq of sequences) {
                if (seq === '/') {
                    decoded += ' ';
                } else if (seq && seq !== '') {
                    decoded += MORSE_TO_CHAR_MAP[seq] || '?';
                }
            }
            document.getElementById('paddleDecoded').textContent = decoded || '解読された文字';
        }
        
        document.getElementById('paddleClear').addEventListener('click', () => {
            paddleBuffer = '';
            paddleSequence = '';
            clearPaddleTimers();
            updatePaddleDisplay();
        });
        
        // キーボード入力対応。
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.repeat) return;
            
            const activeTab = document.querySelector('.tab.active').dataset.tab;
            
            if (activeTab === 'straight') {
                const key = e.key === ' ' ? 'Space' : e.key;
                if (key === settings.straightKey) {
                    e.preventDefault();
                    if (!straightKeyDown) {
                        ensureAudioContext();
                        if (audioContext.state === 'suspended') {
                            audioContext.resume();
                        }
                        straightKeyDown = true;
                        straightKeyDownTime = Date.now();
                        clearStraightTimers();
                        startStraightTone();
                    }
                }
            } else if (activeTab === 'paddle') {
                if (e.key.toLowerCase() === settings.paddleLeft.toLowerCase()) {
                    e.preventDefault();
                    if (!paddleLeftDown) {
                        paddleLeftDown = true;
                        if (paddleRightDown) {
                            dotReqCount++;
                        }
                        document.getElementById('paddleLeft').classList.add('active');
                        updateSqueezeIndicator();
                        if (!paddleSending) {
                            sendPaddleElement('.');
                        }
                    }
                } else if (e.key.toLowerCase() === settings.paddleRight.toLowerCase()) {
                    e.preventDefault();
                    if (!paddleRightDown) {
                        paddleRightDown = true;
                        if (paddleLeftDown) {
                            dashReqCount++;
                        }
                        document.getElementById('paddleRight').classList.add('active');
                        updateSqueezeIndicator();
                        if (!paddleSending) {
                            sendPaddleElement('-');
                        }
                    }
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const activeTab = document.querySelector('.tab.active').dataset.tab;
            
            if (activeTab === 'straight') {
                const key = e.key === ' ' ? 'Space' : e.key;
                if (key === settings.straightKey && straightKeyDown) {
                    e.preventDefault();
                    straightKeyDown = false;
                    const duration = Date.now() - straightKeyDownTime;
                    stopStraightTone();
                    const unit = 1200 / settings.wpm;
                    const signal = duration < unit * 2 ? '.' : '-';
                    straightSequence += signal;
                    straightLastInputTime = Date.now();
                    updateStraightDisplay();
                    setStraightTimers();
                }
            } else if (activeTab === 'paddle') {
                if (e.key.toLowerCase() === settings.paddleLeft.toLowerCase()) {
                    e.preventDefault();
                    const wasSqueezing = paddleLeftDown && paddleRightDown;
                    paddleLeftDown = false;
                    dashReqCount = 0;
                    document.getElementById('paddleLeft').classList.remove('active');
                    updateSqueezeIndicator();
                    
                    // Iambic B: スクウィーズから左を離した場合、右が押されていれば長点を追加予約。
                    if (settings.iambicMode === 'B' && wasSqueezing && paddleRightDown && !paddleSending) {
                        setTimeout(() => {
                            if (paddleRightDown && !paddleSending) {
                                sendPaddleElement('-');
                            }
                        }, 10);
                    }
                } else if (e.key.toLowerCase() === settings.paddleRight.toLowerCase()) {
                    e.preventDefault();
                    const wasSqueezing = paddleLeftDown && paddleRightDown;
                    paddleRightDown = false;
                    dotReqCount = 0;
                    document.getElementById('paddleRight').classList.remove('active');
                    updateSqueezeIndicator();
                    
                    // Iambic B: スクウィーズから右を離した場合、左が押されていれば短点を追加予約。
                    if (settings.iambicMode === 'B' && wasSqueezing && paddleLeftDown && !paddleSending) {
                        setTimeout(() => {
                            if (paddleLeftDown && !paddleSending) {
                                sendPaddleElement('.');
                            }
                        }, 10);
                    }
                }
            }
        });
    </script>
</body>
</html>
